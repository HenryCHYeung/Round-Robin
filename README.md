# Round-Robin
There are six Java files and one CSV file. The CSV file contains the process ID, arrival time, and burst time of each process, each in its own column. Each row represents a process. The three properties of each process are separated by commas. Note that the Java program only accepts integers from the CSV file. The main method of the Java program is located within the file “RR_Runner.java”. It accepts two parameters: a CSV file and the time quantum. To run the program, compile the Java program by running the command “javac RR_Runner.java”. It then can be executed by running the command “java RR_Runner processes.csv 3”, where “processes.csv” is the CSV file and “3” is the time quantum.

The class “RR_Runner.java” serves as the runner of this program. It reads the CSV file and calls the other classes. The class “Process_Creator” creates a list of processes using the details from the CSV file. The class “Process” includes information about each process, such as arrival time, burst time, waiting time, etc. The class “Clock” keeps track of the current time and increments it. The class “CPU” executes each process and calculates the CPU utilization and throughput. The class “Scheduler” is where the simulation happens. Within this class, the ready queue is implemented using an ArrayList and each process enters that ready queue when its arrival time matches the current time. The simulation runs in a loop until all processes are completed.

After the program is executed, the output is printed on the console. The output details everything that happened during each unit of time, starting from 0 to completion. For each unit of time, the current time, current ready queue, current running process, the initial burst time of the current process, the current burst time of the running process (the amount of time left to execute), and the total burst time left of all processes are printed. If a process enters the ready queue in a time unit, a message would be included for that. Additional messages are also included in the case of a context switch. A context switch occurs when a process has completed execution and when the time quantum runs out. In my implementation, it is important to note that a context switch does not increment the clock, and that the context switch time is assumed to be 1 unit (when used in calculations). Whenever a context switch occurs, the console will reprint the current time, but with a new process included. The context switch time is also not included within the total execution time. The total execution time is simply the sum of all
initial burst times of all processes (the same as the completion time of the last process).

When all processes are finished running, a message saying so will be printed. Afterward, the console will print the total number of context switches, the CPU
utilization, the CPU throughput, the average waiting time, the average turnaround time, as well as the average response time. The CPU utilization is calculated as 1 - ((context switch time * number of context switches) / total execution time. As mentioned above, the context switch time is assumed to be 1 and the total execution time is the sum of all initial burst times of all processes. The CPU throughput is defined as the number of processes completed per unit time, and is calculated by finding the average of the initial burst times of all processes (which means it is unaffected by the time quantum). The waiting time of each process is calculated by subtracting the initial burst time from the turnaround time. The turnaround time of each process is calculated by subtracting the arrival time from the completion time. The response time is calculated by subtracting the arrival time from the time at which the process gets the CPU for the first time.
